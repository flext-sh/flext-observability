"""Comprehensive tests for domain services - achieving high coverage."""

from __future__ import annotations
from flext_core import FlextBus

from flext_core import FlextConfig
from flext_core import FlextConstants
from flext_core import FlextContainer
from flext_core import FlextContext
from flext_core import FlextDecorators
from flext_core import FlextDispatcher
from flext_core import FlextExceptions
from flext_core import h
from flext_core import FlextLogger
from flext_core import x
from flext_core import FlextModels
from flext_core import FlextProcessors
from flext_core import p
from flext_core import FlextRegistry
from flext_core import FlextResult
from flext_core import FlextRuntime
from flext_core import FlextService
from flext_core import t
from flext_core import u

from unittest.mock import Mock

import pytest

from flext_observability.domain.services import (
    FlextAlertDomainService,
    FlextHealthDomainService,
    FlextMetricsDomainService,
)


class TestFlextMetricsDomainService:
    """Test FlextMetricsDomainService class comprehensively."""

    @pytest.fixture
    def metrics_domain_service(self) -> FlextMetricsDomainService:
        """Create FlextMetricsDomainService instance."""
        return FlextMetricsDomainService()

    @pytest.fixture
    def valid_metric(self) -> Mock:
        """Create a valid metric for testing."""
        metric = Mock()
        metric.name = "cpu_usage"
        metric.value = 75.0
        metric.unit = "percentage"
        return metric

    @pytest.fixture
    def invalid_metric_no_name(self) -> Mock:
        """Create an invalid metric with no name."""
        metric = Mock()
        metric.name = ""
        metric.value = 75.0
        metric.unit = "percentage"
        return metric

    @pytest.fixture
    def invalid_metric_negative_count(self) -> Mock:
        """Create an invalid metric with negative count."""
        metric = Mock()
        metric.name = "request_count"
        metric.value = -5.0
        metric.unit = "count"
        return metric

    def test_validate_metric_success(
        self,
        metrics_domain_service: FlextMetricsDomainService,
        valid_metric: Mock,
    ) -> None:
        """Test successful metric validation."""
        result = metrics_domain_service.validate_metric(valid_metric)

        assert result.success
        assert result.data is True

    def test_validate_metric_no_name(
        self,
        metrics_domain_service: FlextMetricsDomainService,
        invalid_metric_no_name: Mock,
    ) -> None:
        """Test metric validation with no name."""
        result = metrics_domain_service.validate_metric(invalid_metric_no_name)

        assert not result.success
        assert "Metric name is required" in result.error

    def test_validate_metric_negative_count(
        self,
        metrics_domain_service: FlextMetricsDomainService,
        invalid_metric_negative_count: Mock,
    ) -> None:
        """Test metric validation with negative count."""
        result = metrics_domain_service.validate_metric(invalid_metric_negative_count)

        assert not result.success
        assert "Count and percentage metrics cannot be negative" in result.error

    def test_validate_metric_negative_percentage(
        self,
        metrics_domain_service: FlextMetricsDomainService,
    ) -> None:
        """Test metric validation with negative percentage."""
        metric = Mock()
        metric.name = "cpu_percentage"
        metric.value = -10.0
        metric.unit = "percentage"

        result = metrics_domain_service.validate_metric(metric)

        assert not result.success
        assert "Count and percentage metrics cannot be negative" in result.error


class TestFlextAlertDomainService:
    """Test FlextAlertDomainService class comprehensively."""

    @pytest.fixture
    def alert_domain_service(self) -> FlextAlertDomainService:
        """Create FlextAlertDomainService instance."""
        return FlextAlertDomainService()

    @pytest.fixture
    def critical_alert(self) -> Mock:
        """Create a critical alert for testing."""
        alert = Mock()
        alert.title = "Critical System Error"
        alert.message = "Database connection lost"
        alert.severity = "critical"
        alert.status = "active"
        return alert

    @pytest.fixture
    def medium_alert(self) -> Mock:
        """Create a medium severity alert for testing."""
        alert = Mock()
        alert.title = "High CPU Usage"
        alert.message = "CPU usage above 80%"
        alert.severity = "medium"
        alert.status = "active"
        return alert

    def test_should_escalate_critical(
        self,
        alert_domain_service: FlextAlertDomainService,
        critical_alert: Mock,
    ) -> None:
        """Test escalation for critical alert."""
        result = alert_domain_service.should_escalate(critical_alert)

        assert result.success
        assert result.data is True

    def test_should_escalate_medium(
        self,
        alert_domain_service: FlextAlertDomainService,
        medium_alert: Mock,
    ) -> None:
        """Test escalation for medium alert."""
        result = alert_domain_service.should_escalate(medium_alert)

        assert result.success
        assert result.data is False


class TestFlextHealthDomainService:
    """Test FlextHealthDomainService class comprehensively."""

    @pytest.fixture
    def health_domain_service(self) -> FlextHealthDomainService:
        """Create FlextHealthDomainService instance."""
        return FlextHealthDomainService()

    @pytest.fixture
    def healthy_checks(self) -> list[Mock]:
        """Create healthy health checks."""
        check1 = Mock()
        check1.component = "database"
        check1.status = "healthy"
        check1.message = "DB operational"

        check2 = Mock()
        check2.component = "cache"
        check2.status = "healthy"
        check2.message = "Cache operational"

        return [check1, check2]

    @pytest.fixture
    def mixed_checks(self) -> list[Mock]:
        """Create mixed health checks."""
        check1 = Mock()
        check1.component = "database"
        check1.status = "healthy"
        check1.message = "DB operational"

        check2 = Mock()
        check2.component = "cache"
        check2.status = "failed"
        check2.message = "Cache down"

        return [check1, check2]

    @pytest.fixture
    def degraded_checks(self) -> list[Mock]:
        """Create degraded health checks."""
        check1 = Mock()
        check1.component = "database"
        check1.status = "healthy"
        check1.message = "DB operational"

        check2 = Mock()
        check2.component = "cache"
        check2.status = "degraded"
        check2.message = "Cache slow"

        return [check1, check2]

    def test_calculate_overall_health_empty(
        self,
        health_domain_service: FlextHealthDomainService,
    ) -> None:
        """Test overall health calculation with no checks."""
        result = health_domain_service.calculate_overall_health([])

        assert result.success
        assert result.data == "unknown"

    def test_calculate_overall_health_all_healthy(
        self,
        health_domain_service: FlextHealthDomainService,
        healthy_checks: list[Mock],
    ) -> None:
        """Test overall health calculation with all healthy checks."""
        result = health_domain_service.calculate_overall_health(healthy_checks)

        assert result.success
        assert result.data == "healthy"

    def test_calculate_overall_health_failed(
        self,
        health_domain_service: FlextHealthDomainService,
        mixed_checks: list[Mock],
    ) -> None:
        """Test overall health calculation with failed checks."""
        result = health_domain_service.calculate_overall_health(mixed_checks)

        assert result.success
        assert result.data == "unhealthy"

    def test_calculate_overall_health_degraded(
        self,
        health_domain_service: FlextHealthDomainService,
        degraded_checks: list[Mock],
    ) -> None:
        """Test overall health calculation with degraded checks."""
        result = health_domain_service.calculate_overall_health(degraded_checks)

        assert result.success
        assert result.data == "degraded"
